getgenv().config = {
    farm = {
        toggle = false,
        singleTarget = false,
        radius = 70,
        wait = 0.2,
        buyZone = false
    },
    autoLootbag = false,
    autoOrb = false,
    egg = {
        selectedEgg = "",
        amount = 0,
        farm = false
    },
    timeRewards = false,
    spinnerTicket = false,
    fishing = false,
    antiafk = false,
    stairwayToHeaven = false
}
--[[

Made by griffindoescooking

]] --
repeat
    task.wait()
until game:IsLoaded()
if game.PlaceId ~= 8737899170 then
    game.Players.LocalPlayer:Kick("wrong game")
end
print("Pet Simulator 99 | griffindoescooking")

local LocalPlayer = game.Players.LocalPlayer
local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart", true)

local VirtualUser = game:GetService("VirtualUser")
local sqrt = math.sqrt
local pow = math.pow

local Things = game.workspace['__THINGS']
local Instances = Things.Instances
local instanceContainer = Things['__INSTANCE_CONTAINER']
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs
local ShinyRelics = Things.ShinyRelics
local Breakables = Things.Breakables

local Debris = game.workspace['__DEBRIS']
local Map = game.workspace.Map

local ReplicatedStorage = game.ReplicatedStorage
local Network = ReplicatedStorage.Network
local ClientNetwork = require(ReplicatedStorage.Library.Client.Network)

getgenv().coinQueue = {}

local function loadTable(tableName)
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/lua/normal/games/PetSimulator99/tables/"..tableName..".lua"))()
end

local eggTable = loadTable("eggTable")
local zoneNames = loadTable("zoneNames")
local zoneTable = loadTable("zoneTable")

local vendingMachines = {
    Names = {
        "PotionVendingMachine1",
        "EnchantVendingMachine1",
        "FruitVendingMachine1",
        "FruitVendingMachine2",
        "PotionVendingMachine2",
        "EnchantVendingMachine2",
        "RarePotionsVendingMachine1",
        "RareEnchantVendingMachine1",
        "OPPotionsVendingMachine1"
    },
    Zones = {
        ["PotionVendingMachine1"] = "6 | Cherry Blossom",
        ["EnchantVendingMachine1"] = "9 | Misty Falls",
        ["FruitVendingMachine1"] = "14 | Mushroom Field",
        ["FruitVendingMachine2"] = "26 | Pirate Cove",
        ["PotionVendingMachine2"] = "35 | Safari",
        ["EnchantVendingMachine2"] = "42 | Fire and Ice",
        ["RarePotionsVendingMachine1"] = "47 | Underworld Bridge",
        ["RareEnchantVendingMachine1"] = "51 | Samurai Village",
        ["OPPotionsVendingMachine1"] = "64 | Ice Sculptures"
    }
}
local dailyRewards = {
    Names = {
        "SmallDailyDiamonds",
        "DailyPotions",
        "DailyEnchants",
        "DailyItems",
        "MediumDailyDiamonds"
    },
    Zones = {
        ["SmallDailyDiamonds"] = "3 | Castle",
        ["DailyPotions"] = "17 | Jungle",
        ["DailyEnchants"] = "21 | Coral Reef",
        ["DailyItems"] = "24 | Palm Beach",
        ["MediumDailyDiamonds"] = "32 | Red Desert"
    }
}
local otherRewards = {
    Names = {
        "GroupRewards",
        "SocialRewards",
        "SpinnyWheel",
        "DaycareMachine"
    },
    Zones = {
        ["GroupRewards"] = "1 | Spawn",
        ["SocialRewards"] = "1 | Spawn",
        ["SpinnyWheel"] = "3 | Castle",
        ["DaycareMachine"] = "20 | Beach"
    }
}
local otherMachines = {
    Names = {
        "Mailbox",
        "PetIndexMachine",
        "TransferMachine",
        "VIPRewards",
        "EquipSlotsMachine",
        "EggSlotsMachine",
        "GoldMachine",
        "UpgradePotionsMachine",
        "UpgradeEnchantsMachine",
        "RegularMerchant",
        "FuseMachine",
        "RainbowMachine",
        "AdvancedMerchant",
        "CometShower",
        "UpgradeFruitsMachine",
        "GardenMerchant",
        "SnowMerchant"
    },
    Zones = {
        ["Mailbox"] = "1 | Spawn",
        ["PetIndexMachine"] = "1 | Spawn",
        ["TransferMachine"] = "1 | Spawn",
        ["VIPRewards"] = "1 | Spawn",
        ["EquipSlotsMachine"] = "4 | Green Forest",
        ["EggSlotsMachine"] = "8 | Backyard",
        ["GoldMachine"] = "10 | Mine",
        ["UpgradePotionsMachine"] = "13 | Dark Forest",
        ["UpgradeEnchantsMachine"] = "16 | Crimson Forest",
        ["RegularMerchant"] = "19 | Oasis",
        ["FuseMachine"] = "28 | Shanty Town",
        ["RainbowMachine"] = "31 | Desert Pyramids",
        ["AdvancedMerchant"] = "39 | Ice Rink",
        ["CometShower"] = "44 | Obsidian Cave",
        ["UpgradeFruitsMachine"] = "52 | Bamboo Forest",
        ["GardenMerchant"] = "54 | Flower Field",
        ["SnowMerchant"] = "63 | Frost Mountains"
    }
}
local minigamesTable = {
    "Atlantis",
    "ChestRush",
    "Digsite",
    "Fishing",
    "FlowerGarden",
    "IceObby",
    "JungleObby",
    "Minecart",
    "Minefield",
    "PyramidObby",
    "SledRace",
    "SpawnObby"
}
local eventThings = {
    Names = {
        "AdventCalendar",
        "UpgradePresentsMachine"
    },
    Zones = {
        ["AdventCalendar"] = "1 | Spawn",
        ["UpgradePresentsMachine"] = "1 | Spawn"
    }
}

local function calcDistance(obj1, obj2)
    local pPosX, pPosZ = obj1.CFrame.X, obj1.CFrame.Z
    local hPosX, hPosZ = obj2.CFrame.X, obj2.CFrame.Z

    return sqrt(pow(pPosX - hPosX, 2) + pow(pPosZ - hPosZ, 2))
end
local function clickPosition(x,y)
    VirtualUser:Button1Down(Vector2.new(x,y))
    VirtualUser:Button1Up(Vector2.new(x,y))
end
local function goToPart(cframe)
    HumanoidRootPart.CFrame = cframe
end
local function waitFor(path, object, bool)
    bool = bool or false
    repeat 
        task.wait() 
    until path:FindFirstChild(object, bool)
    return path:FindFirstChild(object, bool)
end
local function checkActive(name, check)
    check = check or true
    if not instanceContainer.Active:FindFirstChild(name) and check then
        goToPart(Instances[name]:FindFirstChild("Enter", true).CFrame) 
    end
end
local function completeObby(path, name)
    local startLine = waitFor(path, "StartLine")
    local endPad = waitFor(path, "Goal").Pad
    if startLine:FindFirstChild("Part") then
        goToPart(startLine:FindFirstChild("Part").CFrame + Vector3.new(0,3,0))
    else
        goToPart(startLine.CFrame + Vector3.new(0,3,0))
    end
    task.wait(0.2)

    local common = require(instanceContainer.Active:FindFirstChild(name):FindFirstChild("Common", true))
    common.WinTimer = 0

    goToPart(endPad.CFrame + Vector3.new(0,3,0))
end
local function Fire(name, args)
    ClientNetwork.Fire(name, unpack(args))
end
local function Invoke(name, args)
    ClientNetwork.Invoke(name, unpack(args))
end

local project = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
local main = project:Window({
    Title = "Pet Simulator 99"
})
local farming = main:Tab({
    Name = "Farming",
    tabColor = Color3.fromHex("#71d1f5"),
    Image = "rbxassetid://10709769841"
})
local teleports = main:Tab({
    Name = "Teleports",
    tabColor = Color3.fromHex("#9bf038"),
    Image = "rbxassetid://15555209580"
})
local minigames = main:Tab({
    Name = "Minigames",
    tabColor = Color3.fromHex("#d19b4a"),
    Image = "rbxassetid://10723376114"
})
local rewards = main:Tab({
    Name = "Rewards",
    tabColor = Color3.fromHex("#da0a48"),
    Image = "rbxassetid://10723396402"
})
local misc = main:Tab({
    Name = "Miscellaneous",
    tabColor = Color3.fromHex("#34d793"),
    Image = "rbxassetid://10709819149"
})
local credits = main:Tab({
    Name = "Credits",
    Image = "rbxassetid://10747373176"
})

local antiAFK
farming:Toggle({
    Name = "Farm Coins",
    Default = false,
    Callback = function(value)
        config.farm.toggle = value

        local doingQueue = false

        while config.farm.toggle and task.wait() do
            for _, v in ipairs(Breakables:GetChildren()) do
                
                if v:FindFirstChild("Hitbox", true) then
                    local part = v:FindFirstChild("Hitbox", true)
                    if calcDistance(part, HumanoidRootPart) <= config.farm.radius then

                        if config.farm.singleTarget then
                            
                            repeat
                                task.wait(config.farm.wait)
                                Fire("Breakables_PlayerDealDamage", {v.Name})
                            until not Breakables:FindFirstChild(v.Name) or calcDistance(part, HumanoidRootPart) > config.farm.radius or not config.farm.toggle or not config.farm.singleTarget
                        
                        else

                            if not table.find(coinQueue, v.Name) then
                                table.insert(coinQueue, v.Name)
                                task.spawn(function()
                                    local coinPart = part
                                    local coinName = v.Name
                                    repeat
                                        task.wait()
                                    until not Breakables:FindFirstChild(coinName) or calcDistance(coinPart, HumanoidRootPart) > config.farm.radius or config.farm.singleTarget or not config.farm.toggle
                                    table.remove(coinQueue, table.find(coinQueue, coinName))
                                end)
                            end
                            task.spawn(function()
                                if not doingQueue then
                                    doingQueue = true
                                    for _,currentCoin in ipairs(coinQueue) do
                                        Fire("Breakables_PlayerDealDamage", {currentCoin})
                                        task.wait(config.farm.wait)
                                    end
                                    doingQueue = false
                                end
                            end)

                        end

                    end
                end
            end
        end
        table.clear(coinQueue)
    end
})
farming:Toggle({
    Name = "Single Target",
    Default = false,
    Callback = function(value)
        config.farm.singleTarget = value
    end
})
farming:TextBox({
    Name = "Radius (Recommended: 70)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.radius = tonumber(value)
        else
            config.farm.radius = 40
            main:Notify({
                Title = "Radius Error",
                Duration = 20,
                Body = "You need the RADIUS to be a number. It is now 40"
            })
        end
    end
})
farming:TextBox({
    Name = "Wait Time (Recommended: 0.2)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.wait = tonumber(value)
        else
            config.farm.wait = 0.2
            main:Notify({
                Title = "Wait Time Error",
                Duration = 20,
                Body = "You need the WAIT TIME to be a number. It is now 0.2"
            })
        end
    end
})
farming:Toggle({
    Name = "Buy Next Zone",
    Default = false,
    Callback = function(value)
        config.farm.buyZone = value
        for _,zoneName in ipairs(zoneNames) do
            if not config.farm.buyZone then break end
            task.spawn(function() 
                while config.farm.buyZone and task.wait() do
                    local name = string.split(zoneName, " | ")[2]
                    Invoke("Zones_RequestPurchase", {name})
                end
            end)
        end
    end
})
farming:Section("Collection")
farming:Toggle({
    Name = "Collect Orbs",
    Default = false,
    Callback = function(value)
        config.autoOrb = value
        local orbModule = require(ReplicatedStorage.Library.Client.OrbCmds.Orb)

        if config.autoOrb then
            orbModule.DefaultPickupDistance = 9e9
        else
            orbModule.DefaultPickupDistance = 20
        end
    end
})
local collectLootbags
collectLootbags = farming:Toggle({
    Name = "Collect Lootbags",
    Default = false,
    Callback = function(value)
        config.autoLootbag = value
        while config.autoLootbag and task.wait() do
            for _, lootbag in ipairs(Lootbags:GetDescendants()) do
                if not config.autoLootbag then break end
                if lootbag:IsA("MeshPart") then
                    lootbag.CFrame = HumanoidRootPart.CFrame
                end
            end
        end
    end
})
farming:Section("Egg Farming")
farming:Label("You must be near eggs to hatch them")
farming:Dropdown({
    Name = "Egg to farm",
    Items = eggTable,
    Multiselect = false,
    Callback = function(eggPicked)
        config.egg.selectedEgg = eggPicked
    end
})
farming:Slider({
    Name = "Amount of eggs",
    Max = 99,
    Min = 1,
    Callback = function(eggAmount)
        config.egg.amount = eggAmount
    end
})
farming:Toggle({
    Name = "Farm selected egg",
    Default = false,
    Callback = function(value)
        config.egg.farm = value
        while config.egg.farm and task.wait() do
            local splitName = string.split(config.egg.selectedEgg, " | ")
            Invoke("Eggs_RequestPurchase",{splitName[2], config.egg.amount})
            task.wait(0.4)
            repeat
                task.wait()
                clickPosition(math.huge,math.huge)
            until not game.workspace.Camera:FindFirstChild("Eggs") or not config.egg.farm
            task.wait(0.75)
        end 
    end
})
farming:Section("Fishing")
local fishingStatus = false
farming:Toggle({
    Name = "Start fishing",
    Default = false,
    Callback = function(value)
        config.fishing = value
        antiAFK:SetValue(config.fishing)
        checkActive("Fishing", config.fishing)
        task.wait(0.2)
        local fishing = waitFor(instanceContainer.Active, "Fishing")
        local fishingModule = require(fishing.ClientModule.FishingGame)
        local Layer1 =  waitFor(fishing.Water, "Layer1")
        local Bobbers = waitFor(fishing, "Bobbers")
        local L1Position = Layer1.Position
        local function fishingRemote(args)
            return Fire("Instancing_FireCustomFromClient", {"Fishing", unpack(args)})
        end
        local function isBubbling()
            local bubbling = false
            for _,host in ipairs(Debris:GetChildren()) do
                if host.Name == "host" and host:FindFirstChild("Attachment") and (host.Attachment:FindFirstChild("Bubbles") or host.Attachment:FindFirstChild("Rare Bubbles")) then
                    local distance = (HumanoidRootPart.Position.X - host.Position.X)
                    if distance <= 2 then
                        bubbling = true
                    end
                end
            end
            return bubbling
        end
        local oldStartGame,oldStopGame,oldIsFishInBar
        oldStartGame = hookfunction(fishingModule.StartGame, function(...)
            fishingStatus = true
            return oldStartGame(...)
        end)
        oldStopGame = hookfunction(fishingModule.StopGame, function(...)
            fishingStatus = false
            return oldStopGame(...)
        end)
        oldIsFishInBar = hookfunction(fishingModule.IsFishInBar, function(...) 
            if config.fishing then
                return true
            else
                return oldIsFishInBar(...)
            end
        end)
        while config.fishing and task.wait() do
            if HumanoidRootPart.Position ~= L1Position and config.fishing then
                goToPart(Layer1.CFrame)
            end
            fishingRemote({"RequestCast", Vector3.new(L1Position.X,L1Position.Y,L1Position.Z)})
            repeat task.wait() until isBubbling() or not config.fishing
            fishingRemote({"RequestReel"})
            repeat task.wait() until (not fishingStatus) or not config.fishing
        end
        goToPart(fishing.Interactable:FindFirstChild("Pad", true).CFrame + Vector3.new(0,3,0))
    end
})

teleports:Label("Miscellaneous")
teleports:Button({
    Name = "Remove water",
    Callback = function() 
        for _, water in ipairs(Map:GetDescendants()) do
            if water:IsA("Folder") and water.Name == "Water Bounds" then
                water:Destroy()
            end
        end
    end
})
teleports:Section("Zones")
local selectedZone = ""
local goToZone
teleports:Dropdown({
    Name = "Zones",
    Items = zoneNames,
    Multiselect = false,
    Callback = function(name) 
        selectedZone = name
        goToZone:SetText("Go to "..selectedZone)
    end
})
goToZone = teleports:Button({
    Name = "Go to none",
    Callback = function()
        goToPart(zoneTable[selectedZone])
    end
})
teleports:Section("Vending Machines")
local vendingName = ""
local goToVendingMachine
teleports:Dropdown({
    Name = "Vending Machines",
    Items = vendingMachines.Names,
    Multiselect = false,
    Callback = function(name)
        vendingName = name
        goToVendingMachine:SetText("Go to "..vendingName)
    end
})
goToVendingMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = vendingMachines.Zones[vendingName]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local vendingPad = waitFor(world.INTERACT.Machines, vendingName).Pad.CFrame
        goToPart(vendingPad)
    end
})
teleports:Section("Other Machines")
local otherMachine = ""
local goToOtherMachine
teleports:Dropdown({
    Name = "Other Machines",
    Items = otherMachines.Names,
    Multiselect = false,
    Callback = function(name)
        otherMachine = name
        goToOtherMachine:SetText("Go to "..otherMachine)
    end
})
goToOtherMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = otherMachines.Zones[otherMachine]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local machinePad = waitFor(world.INTERACT.Machines, otherMachine).Pad.CFrame
        goToPart(machinePad)
    end
})

local selectedMinigame = ""
local goToMinigame
minigames:Dropdown({
    Name = "Select minigame",
    Items = minigamesTable,
    Multiselect = false,
    Callback = function(item)
        selectedMinigame = item
        goToMinigame:SetText(selectedMinigame)
    end
})
goToMinigame = minigames:Button({
    Name = "Go to none",
    Callback = function()
        goToPart(Things.Instances[selectedMinigame]:FindFirstChild("Enter", true).CFrame)
    end
})
minigames:Section("Auto Complete")
minigames:Button({
    Name = 'Complete "Spawn Obby"',
    Callback = function()
        checkActive("SpawnObby")
        task.wait(1)
        local spawnObby = waitFor(instanceContainer.Active, "SpawnObby")
        task.wait(1)
        completeObby(spawnObby, "SpawnObby")
    end
})
minigames:Button({
    Name = 'Complete "Minefield"',
    Callback = function()
        checkActive("Minefield")
        task.wait(1)
        local minefield = waitFor(instanceContainer.Active, "Minefield")
        
        -- this may or may not do anything?
        local common = require(minefield.Common)
        common.Config.RespawnTimer = 0
        common.Config.WinTimer = 0
        
        local mines = waitFor(minefield, "Mines")
        local finish = waitFor(minefield, "Finish")
        local nextX,nextZ = 0, 0
        for _,mine in ipairs(mines:GetChildren()) do
            if nextX == 0 then
                local oldPos = mine.Pad.CFrame
                mine.Pad.CanCollide = false
                nextX = mine.Pad.Position.X
                nextZ = mine.Pad.Position.Z
                mine.Pad.CFrame = HumanoidRootPart.CFrame
                task.wait(0.2)
                mine.Pad.CFrame = oldPos
                mine.Pad.CanCollide = true
                if tostring(mine.Pad.BrickColor) == "Really red" then
                    nextZ = nextZ + 10
                    task.wait(2)
                else
                    nextX = nextX + 10
                end
            else
                if mine.Pad.Position.X == nextX and mine.Pad.Position.Z == nextZ then
                    local oldPos = mine.Pad.CFrame
                    mine.Pad.CanCollide = false
                    mine.Pad.CFrame = HumanoidRootPart.CFrame
                    task.wait(0.2)
                    mine.Pad.CFrame = oldPos
                    mine.Pad.CanCollide = true
                    if tostring(mine.Pad.BrickColor) == "Really red" then
                        nextZ = nextZ + 10
                        task.wait(2)
                    else
                        nextX = nextX + 10
                    end
                end
            end
        end
        goToPart(finish.CFrame)
    end
})
minigames:Button({
    Name = 'Complete "Jungle Obby"',
    Callback = function() 
        checkActive("JungleObby")
        task.wait(1)
        local jungleObby = waitFor(instanceContainer.Active, "JungleObby")
        task.wait(1)
        completeObby(jungleObby.Interactable, "JungleObby")
    end
})
minigames:Button({
    Name = 'Complete "Atlantis"',
    Callback = function() 
        checkActive("Atlantis")
        task.wait(1)
        local atlantis = waitFor(instanceContainer.Active, "Atlantis")
        local rings = waitFor(atlantis, "Rings")
        for i=1,31 do
            local ring = waitFor(rings, tostring(i))
            task.wait(0.4)
            HumanoidRootPart.CFrame = ring.Collision.CFrame
        end
    end
})
minigames:Button({
    Name = 'Complete "Pyramid Obby"',
    Callback = function() 
        checkActive("PyramidObby")
        task.wait(1)
        local pyramidObby = waitFor(instanceContainer.Active, "PyramidObby")
        task.wait(1)
        completeObby(pyramidObby.Interactable, "PyramidObby")
    end
})
minigames:Button({
    Name = 'Complete "Ice Obby"',
    Callback = function() 
        checkActive("IceObby")
        task.wait(1)
        local iceObby = waitFor(instanceContainer.Active, "IceObby")
        task.wait(1)
        completeObby(iceObby.Interactable, "IceObby")
    end
})
minigames:Button({
    Name = 'Complete "Minecart"',
    Callback = function()
        checkActive("Minecart")
        task.wait(1)
        local minecart = waitFor(instanceContainer.Active, "Minecart")
        task.wait(1)
        local goalPad = waitFor(minecart.Interactable, "Goal").Pad

        HumanoidRootPart.CFrame = CFrame.new(0,0,0) + Vector3.new(-1380.3746337890625, -102.0365982055664, -4659.6044921875)
        task.wait(0.2)

        local common = require(minecart:FindFirstChild("Common", true))
        common.WinTimer = 0

        goToPart(goalPad.CFrame + Vector3.new(0,3,0))
    end
})

rewards:Toggle({
    Name = 'Collect Time Rewards',
    Default = false,
    Callback = function(value)
        config.timeRewards = value
        collectLootbags:SetValue(config.timeRewards)
        while config.timeRewards and task.wait() do
            for i=1,12 do
                Invoke("Redeem Free Gift", {i})
            end
        end
    end
})
rewards:Toggle({
    Name = "Collect Spinner Ticket",
    Default = false,
    Callback = function(value)
        config.spinnerTicket = value
        while config.spinnerTicket and task.wait() do
            Fire("Spinny Wheel: Request Ticket", {"StarterWheel"})
        end
    end
})
rewards:Section("Daily Rewards")
local rewardType = ""
local getDailyReward
rewards:Dropdown({
    Name = "Reward Type",
    Items = dailyRewards.Names,
    Callback = function(value)
        rewardType = value
        getDailyReward:SetText("Get: "..rewardType)
    end
})
getDailyReward = rewards:Button({
    Name = "Get: ",
    Callback = function()
        local oldPos = HumanoidRootPart.CFrame
        local zone = dailyRewards.Zones[rewardType]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT.Machines, rewardType).Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
        task.wait(0.2)
        goToPart(oldPos)
    end
})
rewards:Section("Other Rewards")
local otherRewardType = ""
local goToOtherReward
rewards:Dropdown({
    Name = "Reward Type",
    Items = otherRewards.Names,
    Callback = function(value)
        otherRewardType = value
        goToOtherReward:SetText("Go to "..otherRewardType)
    end
})
goToOtherReward = rewards:Button({
    Name = "Go to none ",
    Callback = function()
        local zone = otherRewards.Zones[otherRewardType]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT.Machines, otherRewardType).Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
    end
})
rewards:Button({
    Name = "Go to Crystal Chest",
    Callback = function() 
        local zone = "3 | Castle"
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT, "CrystalChest").Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
    end
})

misc:Label("These are things that dont fit in a category")
antiAFK = misc:Toggle({
    Name = "Anti AFK",
    Default = false,
    Callback = function(value)
        config.antiafk = value
        while config.antiafk and task.wait() do
            LocalPlayer.Character.Humanoid:ChangeState(3)
            task.wait(math.random(120,180))
        end
    end
})
local shrineButton
shrineButton = misc:Button({
    Name = "Collect Shrines (maybe)",
    Callback = function()
        for i=1,65 do
            shrineButton:SetText("Progress: "..tostring(i).."/65")
            Invoke("Relic_Found", {i})
        end
        shrineButton:SetText("Collect Shrines (Maybe)")
    end
})
local completeStairs
completeStairs = misc:Toggle({
    Name = "Try and complete stairway to heaven",
    Default = false,
    Callback = function(value)
        config.stairwayToHeaven = value
        if config.stairwayToHeaven and not instanceContainer.Active:FindFirstChild("StairwayToHeaven") then
            goToPart(CFrame.new(0,-100,0))
        end
        repeat task.wait() until instanceContainer.Active:FindFirstChild("StairwayToHeaven")
        local stairway = instanceContainer.Active.StairwayToHeaven
        local highestY = 0
        local oldHighest = highestY
        local highestCFrame

        while config.stairwayToHeaven and task.wait() do
            if stairway:FindFirstChild("Goal", true) then
                config.stairwayToHeaven = false
                completeStairs:SetValue(false)
                local goal = stairway:FindFirstChild("Goal", true)
                task.wait(0.3)
                goToPart(goal.Shrine.Pad.CFrame + Vector3.new(0,3,0))
            end
            task.spawn(function() 
                for _,part in ipairs(stairway:GetDescendants()) do
                    if part.Name == "Goal" then
                        config.stairwayToHeaven = false
                        completeStairs:SetValue(false)
                        local goal = stairway:FindFirstChild("Goal", true)
                        task.wait(0.3)
                        goToPart(goal.Shrine.Pad.CFrame + Vector3.new(0,3,0))
                    end
                end
            end)
            for _,section in ipairs(stairway.Stairs:GetChildren()) do
                if not config.stairwayToHeaven then break end

                if section.Name == "Section" then
                    for _,part in ipairs(section:GetChildren()) do
                        if not config.stairwayToHeaven then break end

                        if part.Name == "Part" and part:IsA("Part") then
                            if part.Position.Y > highestY then
                                highestY = part.Position.Y
                                highestCFrame = part.CFrame
                            end
                        end
                    end
                end
            end
            if oldHighest ~= highestY then
                oldHighest = highestY
                pcall(function() 
                    goToPart(highestCFrame + Vector3.new(0,3,0))
                end)
                task.wait(0.2)
            end
        end
    end
})
misc:Label("^ This probably doesn't even work ^")

credits:Label("UI: griffindoescooking")
credits:Label("Script: griffindoescooking, project L")
credits:Button({
    Name = "project L",
    Callback = function()
        setclipboard("https://discord.gg/Mw7rYHDNw4")
    end
})
credits:Section("Support: ")
credits:Button({
    Name = "Discord",
    Callback = function()
        setclipboard("https://discord.gg/DBPHwFyCVT")
    end
})
main:Notify({
    Title = "give me ideas",
    Duration = 20,
    Body = "ran out of things to add join the discord and tell me fr please"
})
