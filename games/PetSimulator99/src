getgenv().config = {
    farm = {
        toggle = false,
        singleTarget = false,
        farmPrint = false,
        radius = 40,
        wait = 0.2
    },
    autoLootbag = false,
    autoOrb = false,
    egg = {
        selectedEgg = "",
        amount = 0,
        farm = false
    },
    timeRewards = false,
    fishing = false,
    antiafk = false
}
--[[

Made by griffindoescooking

]] --
repeat
    task.wait()
until game:IsLoaded()
if game.PlaceId ~= 8737899170 then
    game.Players.LocalPlayer:Kick("wrong game")
end
print("Pet Simulator 99 | griffindoescooking")

local LocalPlayer = game.Players.LocalPlayer
local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart", true)

local VirtualUser = game:GetService("VirtualUser")
local sqrt = math.sqrt
local pow = math.pow

local Things = game.workspace['__THINGS']
local Debris = game.workspace['__DEBRIS']
local Map = game.workspace.Map
local instanceSpawnObby = Things.Instances.SpawnObby
local instanceMinefield = Things.Instances.Minefield
local instanceJungleObby = Things.Instances.JungleObby
local instanceAtlantis = Things.Instances.Atlantis
local instanceFishing = Things.Instances.Fishing
local instanceContainer = Things['__INSTANCE_CONTAINER']
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs
local ShinyRelics = Things.ShinyRelics
local Breakables = Things.Breakables
local Pets = Things.Pets
local Network = game:GetService("ReplicatedStorage").Network
local PetInventory = LocalPlayer.PlayerGui.Inventory.Frame.Main.Pets.EquippedPets

getgenv().currentCoins = {}
getgenv().equippedPets = {}
getgenv().totalClaimed = 0
getgenv().totalTime = 0

local function loadTable(tableName)
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/lua/normal/games/PetSimulator99/tables/"..tableName..".lua"))()
end

local eggTable = loadTable("eggTable")
local zoneNames = loadTable("zoneNames")
local zoneTable = loadTable("zoneTable")
local vendingTable = {
    "PotionVendingMachine1",
    --"PotionVendingMachine2",
    "EnchantVendingMachine1",
    --"EnchantVendingMachine2",
    "FruitVendingMachine1",
    "FruitVendingMachine2",
}
local dailyRewardTable = {
    "DailyEnchants",
    "DailyPotions",
    "DailyItems",
    "SmallDailyDiamonds"
}
local miscThingsTable = {
    "EquipSlotsMachine",
    "EggSlotsMachine",
    "GoldMachine",
    "UpgradePotionsMachine",
    "UpgradeEnchantmentsMachine",
    "RegularMerchant",
    "DaycareMachine",
    "RebirthShrine",
    "FuseMachine",
    "RainbowMachine"
}

local function indexPets()
    table.clear(equippedPets)
    for _, pet in ipairs(Pets:GetChildren()) do
        if PetInventory:FindFirstChild(pet.Name) then
            table.insert(equippedPets, pet.Name)
        end
    end
    return equippedPets
end
local function calcDistance(obj1, obj2)
    local pPosX, pPosZ = obj1.CFrame.X, obj1.CFrame.Z
    local hPosX, hPosZ = obj2.CFrame.X, obj2.CFrame.Z

    return sqrt(pow(pPosX - hPosX, 2) + pow(pPosZ - hPosZ, 2))
end
local function clickPosition(x,y)
    VirtualUser:Button1Down(Vector2.new(x,y))
    VirtualUser:Button1Up(Vector2.new(x,y))
end
local function sendNotification(title, text, duration)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = tonumber(duration),
        Callback = function()
        end,
        Button1 = "Got It!"
    })
end
local function goToPart(cframe)
    HumanoidRootPart.CFrame = cframe
end
local function waitFor(path, object, bool)
    bool = bool or false
    repeat 
        task.wait() 
    until path:FindFirstChild(object, bool)
    return path:FindFirstChild(object, bool)
end

local vendingZones = {
    ["PotionVendingMachine1"] = "6 | Cherry Blossom",
    ["EnchantVendingMachine1"] = "9 | Misty Falls",
    ["FruitVendingMachine1"] = "14 | Mushroom Field",
    ["FruitVendingMachine2"] = "26 | Pirate Cove"
}
local dailyRewardZones = {
    ["DailyEnchants"] = "21 | Coral Reef",
    ["DailyPotions"] = "17 | Jungle",
    ["DailyItems"] = "24 | Palm Beach",
    ["SmallDailyDiamonds"] = "3 | Castle"
}
local miscThingsZones = {
    ["EquipSlotsMachine"] = "4 | Green Forest",
    ["EggSlotsMachine"] = "8 | Backyard",
    ["GoldMachine"] = "10 | Mine",
    ["UpgradePotionsMachine"] = "13 | Dark Forest",
    ["UpgradeEnchantmentsMachine"] = "16 | Crimson Forest",
    ["RegularMerchant"] = "19 | Oasis",
    ["DaycareMachine"] = "20 | Beach",
    ["RebirthShrine"] = "25 | Tiki",
    ["FuseMachine"] = "28 | Shanty Town",
    ["RainbowMachine"] = "31 | Desert Pyramids"
}

local project = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
local main = project:Window({
    Title = "Pet Simulator 99",
    Parent = game.CoreGui
})
local farming = main:Tab({
    Name = "Farming",
    tabColor = Color3.fromHex("#71d1f5"),
    Image = "rbxassetid://10709769841"
})
local teleports = main:Tab({
    Name = "Teleports",
    tabColor = Color3.fromHex("#9bf038"),
    Image = "rbxassetid://15555209580"
})
local obbies = main:Tab({
    Name = "Obbies",
    tabColor = Color3.fromHex("#d19b4a"),
    Image = "rbxassetid://10723376114"
})
local rewards = main:Tab({
    Name = "Rewards",
    tabColor = Color3.fromHex("#da0a48"),
    Image = "rbxassetid://10723396402"
})
local misc = main:Tab({
    Name = "Miscellaneous",
    tabColor = Color3.fromHex("#34d793"),
    Image = "rbxassetid://10709819149"
})
local credits = main:Tab({
    Name = "Credits",
    Image = "rbxassetid://10747373176"
})
local antiAFK
farming:Toggle({
    Name = "Farm Coins",
    Default = false,
    Callback = function(value)
        config.farm.toggle = value
        while config.farm.toggle and task.wait() do
            for _, v in ipairs(Breakables:GetChildren()) do
                if v.Name ~= "Highlight" and v:FindFirstChild("Hitbox", true) then
                    local part = v:FindFirstChild("Hitbox", true)

                    if calcDistance(part, HumanoidRootPart) <= config.farm.radius then
                        if config.farm.singleTarget then
                            local tmpName = v.Name
                            local startTime = os.clock()

                            repeat
                                if calcDistance(part, HumanoidRootPart) > config.farm.radius then
                                    break
                                end
                                task.wait(config.farm.wait)
                                Network.Breakables_PlayerDealDamage:FireServer(v.Name)
                            until not Breakables:FindFirstChild(v.Name)

                            totalClaimed = totalClaimed + 1;
                            totalTime = totalTime + (os.clock() - startTime)
                            if config.farm.farmPrint then
                                print("farmed " .. tmpName .. " in: " .. tostring(os.clock() - startTime) .. " Avg: " .. tostring(totalTime / totalClaimed))
                            end
                        else
                            if not table.find(currentCoins, v.Name) then
                                table.insert(currentCoins, v.Name)
                                task.spawn(function()
                                    local tmpPart = part
                                    local tmpName = v.Name
                                    local startTime = os.clock()
                                    repeat
                                        if calcDistance(tmpPart, HumanoidRootPart) > config.farm.radius then
                                            table.remove(currentCoins, table.find(currentCoins, v.Name))
                                            break
                                        end

                                        task.wait(config.farm.wait * math.random(1, 2))

                                        Network.Breakables_PlayerDealDamage:FireServer(tmpName)
                                    until not Breakables:FindFirstChild(tmpName)

                                    table.remove(currentCoins, table.find(currentCoins, v.Name))
                                    totalClaimed = totalClaimed + 1;
                                    totalTime = totalTime + (os.clock() - startTime)
                                    if config.farm.farmPrint then
                                        print("farmed " .. tmpName .. " in: " .. tostring(os.clock() - startTime) .. " Avg: " .. tostring(totalTime / totalClaimed))
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end
    end
})
farming:Toggle({
    Name = "Single Target",
    Default = false,
    Callback = function(value)
        config.farm.singleTarget = value
    end
})
farming:Toggle({
    Name = "Console Print",
    Default = false,
    Callback = function(value)
        config.farm.farmPrint = value
    end
})
farming:TextBox({
    Name = "Radius (Recommended: 70)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.radius = tonumber(value)
        else
            config.farm.radius = 40
            sendNotification("Radius Error", "You need the RADIUS to be a number. It is now 40", 50)
        end
    end
})
farming:TextBox({
    Name = "Wait Time (Recommended: 0.2)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.wait = tonumber(value)
        else
            config.farm.wait = 0.2
            sendNotification("Wait Time Error", "You need the WAIT TIME to be a number. It is now 0.2", 50)
        end
    end
})
farming:Section("Collection")
farming:Label("Auto Collect Orbs is currently broken/patched")
--[[
farming:Toggle({
    Name = "Collect Orbs",
    Default = false,
    Callback = function(value)
        config.autoOrb = value
        while config.autoOrb and task.wait() do

            for _, orb in ipairs(Orbs:GetChildren()) do
                if orb:IsA("Part") then
                    orb.CFrame = HumanoidRootPart.CFrame
                end
            end

        end
    end
})
]]
farming:Toggle({
    Name = "Collect Lootbags",
    Default = false,
    Callback = function(value)
        config.autoLootbag = value
        while config.autoLootbag and task.wait() do

            for _, lootbag in ipairs(Lootbags:GetDescendants()) do
                if lootbag:IsA("MeshPart") then
                    lootbag.CFrame = HumanoidRootPart.CFrame
                end
            end

        end
    end
})
farming:Section("Egg Farming")
farming:Label("You must be near eggs to hatch them")
farming:Dropdown({
    Name = "Egg to farm",
    Items = eggTable,
    Multiselect = false,
    Callback = function(eggPicked)
        config.egg.selectedEgg = eggPicked
    end
})
farming:Slider({
    Name = "Amount of eggs",
    Step = 1,
    Max = 99,
    Min = 1,
    InitialValue = 1,
    Callback = function(eggAmount)
        config.egg.amount = eggAmount
        print(tostring(config.egg.amount))
    end
})
farming:Toggle({
    Name = "Farm selected egg",
    Default = false,
    Callback = function(value)
        config.egg.farm = value
        while config.egg.farm and task.wait() do
            local splitName = string.split(config.egg.selectedEgg, " | ")

            Network.Eggs_RequestPurchase:InvokeServer(splitName[2],tonumber(config.egg.amount))
            task.wait(0.4)

            repeat 
                task.wait()
                clickPosition(math.huge,math.huge)
            until not game.workspace.Camera:FindFirstChild("Eggs")
            task.wait(0.75)
        end 
    end
})
farming:Section("Fishing")
local fishingStatus = false
farming:Toggle({
    Name = "Start fishing",
    Default = false,
    Callback = function(value)
        config.fishing = value
        
        if not instanceContainer.Active:FindFirstChild("Fishing") and config.fishing then
            goToPart(instanceFishing:FindFirstChild("Enter", true).CFrame) 
        end
    
        task.wait(0.2)
    
        local fishing = waitFor(instanceContainer.Active, "Fishing")
        local fishingModule = require(fishing.ClientModule.FishingGame)
        local Layer1 =  waitFor(fishing.Water, "Layer1")
        local Bobbers = waitFor(fishing, "Bobbers")
        local L1Position = Layer1.Position
        
        if HumanoidRootPart.Position ~= L1Position and config.fishing then
           goToPart(Layer1.CFrame) 
        end
        
        local function fishingRemote(arg1, arg2)
            if arg2 then
                return Network.Instancing_FireCustomFromClient:FireServer("Fishing",arg1, arg2)
            end
            return Network.Instancing_FireCustomFromClient:FireServer("Fishing",arg1)
        end
        local function isBubbling()
            local bubbling = false
            for _,host in ipairs(Debris:GetChildren()) do
                if host.Name == "host" and host:FindFirstChild("Attachment") and (host.Attachment:FindFirstChild("Bubbles") or host.Attachment:FindFirstChild("Rare Bubbles")) then
                    local distance = (HumanoidRootPart.Position.X - host.Position.X)
                    if distance <= 2 then
                        bubbling = true
                    end
                end
            end
            return bubbling
        end
        
        local oldStartGame,oldStopGame,oldIsFishInBar
        oldStartGame = hookfunction(fishingModule.StartGame, function(...)
            fishingStatus = true
            return oldStartGame(...)
        end)
        oldStopGame = hookfunction(fishingModule.StopGame, function(...)
            fishingStatus = false
            return oldStopGame(...)
        end)
        oldIsFishInBar = hookfunction(fishingModule.IsFishInBar, function(...) 
            if config.fishing then
                return true
            else
                return oldIsFishInBar(...)
            end
        end)
        
        while config.fishing and task.wait() do
            
            fishingRemote("RequestCast", Vector3.new(L1Position.X,L1Position.Y,L1Position.Z))
            
            repeat task.wait() until isBubbling() and config.fishing
            
            fishingRemote("RequestReel")
            
            repeat task.wait() until (not fishingStatus) and config.fishing
            
        end
        goToPart(fishing.Interactable:FindFirstChild("Pad", true).CFrame + Vector3.new(0,3,0))
    end
})

teleports:Label("Miscellaneous")
teleports:Button({
    Name = "Remove water",
    Callback = function() 
        for _, water in ipairs(Map:GetDescendants()) do
            if water:IsA("Folder") and water.Name == "Water Bounds" then
                water:Destroy()
            end
        end
    end
})
teleports:Section("Zones")
local selectedZone = ""
local goToZone
teleports:Dropdown({
    Name = "Zones",
    Items = zoneNames,
    Multiselect = false,
    Callback = function(name) 
        selectedZone = name
        goToZone:SetText("Go to "..selectedZone)
    end
})
goToZone = teleports:Button({
    Name = "Go to none",
    Callback = function()
        goToPart(zoneTable[selectedZone])
    end
})
teleports:Section("Vending Machines")
local vendingName = ""
local goToVendingMachine
teleports:Dropdown({
    Name = "Vending Machines",
    Items = vendingTable,
    Multiselect = false,
    Callback = function(name)
        vendingName = name
        goToVendingMachine:SetText("Go to "..vendingName)
    end
})
goToVendingMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = vendingZones[vendingName]
        goToPart(zoneTable[zone])
        local world = waitFor(Map, zone)
        local vendingPad = waitFor(world.INTERACT.Machines, vendingName).Pad.CFrame
        goToPart(vendingPad)
    end
})
teleports:Section("Other Machines")
local miscMachine = ""
local goToMiscMachine
teleports:Dropdown({
    Name = "Other Machines",
    Items = miscThingsTable,
    Multiselect = false,
    Callback = function(name)
        miscMachine = name
        goToMiscMachine:SetText("Go to "..miscMachine)
    end
})
goToMiscMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = miscThingsZones[miscMachine]
        goToPart(zoneTable[zone])
        local world = waitFor(Map, zone)
        local machinePad = waitFor(world.INTERACT.Machines, miscMachine).Pad.CFrame
        goToPart(machinePad)
    end
})

obbies:Button({
    Name = 'Complete "Spawn Obby"',
    Callback = function()
        goToPart(instanceSpawnObby:FindFirstChild("Enter", true).CFrame)
        task.wait(1)
        
        local spawnObby = waitFor(instanceContainer.Active, "SpawnObby")
        local startLine = waitFor(spawnObby, "StartLine")
        local endPad = waitFor(spawnObby, "Goal").Pad
        
        
        goToPart(startLine:FindFirstChild("Part").CFrame + Vector3.new(0,3,0))
        task.wait(1)
        goToPart(endPad.CFrame + Vector3.new(0,3,0))
    end
})
obbies:Button({
    Name = 'Complete "Minefield"',
    Callback = function()
        goToPart(instanceMinefield:FindFirstChild("Enter", true).CFrame)
        task.wait(1)
        
        local minefield = waitFor(instanceContainer.Active, "Minefield")
        local mines = waitFor(minefield, "Mines")
        local finish = waitFor(minefield, "Finish")
        
        local nextX,nextZ = 0, 0
        for _,mine in ipairs(mines:GetChildren()) do
            if nextX == 0 then
                local oldPos = mine.Pad.CFrame
                mine.Pad.CanCollide = false
                nextX = mine.Pad.Position.X
                nextZ = mine.Pad.Position.Z
                
                mine.Pad.CFrame = HumanoidRootPart.CFrame
                task.wait(0.2)
                mine.Pad.CFrame = oldPos
                mine.Pad.CanCollide = true
                
                if tostring(mine.Pad.BrickColor) == "Really red" then
                    nextZ = nextZ + 10
                    task.wait(3)
                else
                    nextX = nextX + 10
                end
            else
                if mine.Pad.Position.X == nextX and mine.Pad.Position.Z == nextZ then
                    local oldPos = mine.Pad.CFrame
                    mine.Pad.CanCollide = false
                    mine.Pad.CFrame = HumanoidRootPart.CFrame
                    task.wait(0.2)
                    mine.Pad.CFrame = oldPos
                    mine.Pad.CanCollide = true
                    
                    if tostring(mine.Pad.BrickColor) == "Really red" then
                        nextZ = nextZ + 10
                        task.wait(3)
                    else
                        nextX = nextX + 10
                    end
                end
            end
        end
        goToPart(finish.CFrame)
    end
})
obbies:Button({
    Name = 'Complete "Jungle Obby"',
    Callback = function() 
        goToPart(instanceJungleObby:FindFirstChild("Enter", true).CFrame)
        task.wait(1)
        
        local jungleObby = waitFor(instanceContainer.Active, "JungleObby")

        local startLine = waitFor(jungleObby, "Interactable").StartLine
        local goalPad = jungleObby.Interactable.Goal.Pad
        
        goToPart(startLine.CFrame + Vector3.new(0,3,0))
        task.wait(1)
        goToPart(goalPad.CFrame + Vector3.new(0,3,0))
    end
})
obbies:Button({
    Name = 'Complete "Atlantis"',
    Callback = function() 
        goToPart(instanceAtlantis:FindFirstChild("Enter", true).CFrame)
        task.wait(1)

        local atlantis = waitFor(instanceContainer.Active, "Atlantis")
        local rings = waitFor(atlantis, "Rings")

        for i=1,31 do
            local ring = waitFor(rings, tostring(i))
            task.wait(0.4)
            HumanoidRootPart.CFrame = ring.Collision.CFrame
        end
    end
})

rewards:Toggle({
    Name = 'Collect Time Rewards',
    Default = false,
    Callback = function(value)
        config.timeRewards = value
        while config.timeRewards and task.wait() do
            for i=1,12 do
                Network:FindFirstChild("Redeem Free Gift"):InvokeServer(i)
            end
        end
    end
})
rewards:Section("Daily Rewards")
local rewardType = ""
local getDailyReward
rewards:Dropdown({
    Name = "Reward Type",
    Items = dailyRewardTable,
    Callback = function(value)
        rewardType = value
        getDailyReward:SetText("Get: "..rewardType)
    end
})
getDailyReward = rewards:Button({
    Name = "Get: ",
    Callback = function()
        local oldPos = HumanoidRootPart.CFrame
        
        local zone = dailyRewardZones[rewardType]
        goToPart(zoneTable[zone])
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT.Machines, rewardType).Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
        
        task.wait(0.2)
        goToPart(oldPos + Vector3.new(0,3,0))
    end
})

misc:Label("These are things that dont fit in a category")
antiAFK = misc:Toggle({
    Name = "Anti AFK",
    Default = false,
    Callback = function(value)
        config.antiafk = value
        while config.antiafk and task.wait() do
            LocalPlayer.Character.Humanoid:ChangeState(3)
            task.wait(math.random(120,180))
        end
    end
})

credits:Label("UI: griffindoescooking")
credits:Label("Script: griffindoescooking, project L")
credits:Button({
    Name = "project L",
    Callback = function()
        setclipboard("https://discord.gg/Mw7rYHDNw4")
    end
})
credits:Section("Support: ")
credits:Button({
    Name = "Discord",
    Callback = function()
        setclipboard("https://discord.gg/DBPHwFyCVT")
    end
})
