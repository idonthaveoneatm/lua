getgenv().config = {
    farm = {
        toggle = false,
        singleTarget = false,
        radius = 70,
        wait = 0.2
    },
    autoLootbag = false,
    autoOrb = false,
    egg = {
        selectedEgg = "",
        amount = 0,
        farm = false
    },
    timeRewards = false,
    fishing = false,
    antiafk = false,
    event = {
        farm = false,
    }
}
--[[

Made by griffindoescooking

]] --
repeat
    task.wait()
until game:IsLoaded()
if game.PlaceId ~= 8737899170 then
    game.Players.LocalPlayer:Kick("wrong game")
end
print("Pet Simulator 99 | griffindoescooking")

local LocalPlayer = game.Players.LocalPlayer
local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart", true)

local VirtualUser = game:GetService("VirtualUser")
local sqrt = math.sqrt
local pow = math.pow

local Things = game.workspace['__THINGS']
local Debris = game.workspace['__DEBRIS']
local Map = game.workspace.Map
local Instances = Things.Instances
local instanceContainer = Things['__INSTANCE_CONTAINER']
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs
local ShinyRelics = Things.ShinyRelics
local Breakables = Things.Breakables
local Pets = Things.Pets
local Network = game:GetService("ReplicatedStorage").Network
local PetInventory = LocalPlayer.PlayerGui.Inventory.Frame.Main.Pets.EquippedPets

getgenv().currentCoins = {}
getgenv().equippedPets = {}
getgenv().totalClaimed = 0
getgenv().totalTime = 0

local function loadTable(tableName)
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/lua/normal/games/PetSimulator99/tables/"..tableName..".lua"))()
end

local eggTable = loadTable("eggTable")
local zoneNames = loadTable("zoneNames")
local zoneTable = loadTable("zoneTable")

local vendingMachines = {
    Names = {
        "PotionVendingMachine1",
        "EnchantVendingMachine1",
        "FruitVendingMachine1",
        "FruitVendingMachine2",
        "PotionVendingMachine2",
        "EnchantVendingMachine2",
        "RarePotionsVendingMachine1",
        "RareEnchantVendingMachine1",
        "OPPotionsVendingMachine1"
    },
    Zones = {
        ["PotionVendingMachine1"] = "6 | Cherry Blossom",
        ["EnchantVendingMachine1"] = "9 | Misty Falls",
        ["FruitVendingMachine1"] = "14 | Mushroom Field",
        ["FruitVendingMachine2"] = "26 | Pirate Cove",
        ["PotionVendingMachine2"] = "35 | Safari",
        ["EnchantVendingMachine2"] = "42 | Fire and Ice",
        ["RarePotionsVendingMachine1"] = "47 | Underworld Bridge",
        ["RareEnchantVendingMachine1"] = "51 | Samurai Village",
        ["OPPotionsVendingMachine1"] = "64 | Ice Sculptures"
    }
}
local dailyRewards = {
    Names = {
        "SmallDailyDiamonds",
        "DailyPotions",
        "DailyEnchants",
        "DailyItems",
        "MediumDailyDiamonds"
    },
    Zones = {
        ["SmallDailyDiamonds"] = "3 | Castle",
        ["DailyPotions"] = "17 | Jungle",
        ["DailyEnchants"] = "21 | Coral Reef",
        ["DailyItems"] = "24 | Palm Beach",
        ["MediumDailyDiamonds"] = "32 | Red Desert"
    }
}
local otherRewards = {
    Names = {
        "GroupRewards",
        "SocialRewards",
        "SpinnyWheel",
        "DaycareMachine"
    },
    Zones = {
        ["GroupRewards"] = "1 | Spawn",
        ["SocialRewards"] = "1 | Spawn",
        ["SpinnyWheel"] = "3 | Castle",
        ["DaycareMachine"] = "20 | Beach"
    }
}
local otherMachines = {
    Names = {
        "Mailbox",
        "PetIndexMachine",
        "TransferMachine",
        "VIPRewards",
        "EquipSlotsMachine",
        "EggSlotsMachine",
        "GoldMachine",
        "UpgradePotionsMachine",
        "UpgradeEnchantsMachine",
        "RegularMerchant",
        "FuseMachine",
        "RainbowMachine",
        "AdvancedMerchant",
        "CometShower",
        "UpgradeFruitsMachine",
        "GardenMerchant",
        "SnowMerchant"
    },
    Zones = {
        ["Mailbox"] = "1 | Spawn",
        ["PetIndexMachine"] = "1 | Spawn",
        ["TransferMachine"] = "1 | Spawn",
        ["VIPRewards"] = "1 | Spawn",
        ["EquipSlotsMachine"] = "4 | Green Forest",
        ["EggSlotsMachine"] = "8 | Backyard",
        ["GoldMachine"] = "10 | Mine",
        ["UpgradePotionsMachine"] = "13 | Dark Forest",
        ["UpgradeEnchantsMachine"] = "16 | Crimson Forest",
        ["RegularMerchant"] = "19 | Oasis",
        ["FuseMachine"] = "28 | Shanty Town",
        ["RainbowMachine"] = "31 | Desert Pyramids",
        ["AdvancedMerchant"] = "39 | Ice Rink",
        ["CometShower"] = "44 | Obsidian Cave",
        ["UpgradeFruitsMachine"] = "52 | Bamboo Forest",
        ["GardenMerchant"] = "54 | Flower Field",
        ["SnowMerchant"] = "63 | Frost Mountains"
    }
}
local minigamesTable = {
    "Atlantis",
    "ChestRush",
    "Digsite",
    "Fishing",
    "FlowerGarden",
    "IceObby",
    "JungleObby",
    "Minecart",
    "Minefield",
    "PyramidObby",
    "SledRace",
    "SpawnObby"
}
local eventThings = {
    Names = {
        "AdventCalendar",
        "UpgradePresentsMachine"
    },
    Zones = {
        ["AdventCalendar"] = "1 | Spawn",
        ["UpgradePresentsMachine"] = "1 | Spawn"
    }
}

local function indexPets()
    table.clear(equippedPets)
    for _, pet in ipairs(Pets:GetChildren()) do
        if PetInventory:FindFirstChild(pet.Name) then
            table.insert(equippedPets, pet.Name)
        end
    end
    return equippedPets
end
local function calcDistance(obj1, obj2)
    local pPosX, pPosZ = obj1.CFrame.X, obj1.CFrame.Z
    local hPosX, hPosZ = obj2.CFrame.X, obj2.CFrame.Z

    return sqrt(pow(pPosX - hPosX, 2) + pow(pPosZ - hPosZ, 2))
end
local function clickPosition(x,y)
    VirtualUser:Button1Down(Vector2.new(x,y))
    VirtualUser:Button1Up(Vector2.new(x,y))
end
local function sendNotification(title, text, duration)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = tonumber(duration),
        Callback = function()
        end,
        Button1 = "Got It!"
    })
end
local function goToPart(cframe)
    HumanoidRootPart.CFrame = cframe
end
local function waitFor(path, object, bool)
    bool = bool or false
    repeat 
        task.wait() 
    until path:FindFirstChild(object, bool)
    return path:FindFirstChild(object, bool)
end
local function checkActive(name, check)
    check = check or true
    if not instanceContainer.Active:FindFirstChild(name) and check then
        goToPart(Instances[name]:FindFirstChild("Enter", true).CFrame) 
    end
end
local function completeObby(path)
    local startLine = waitFor(path, "StartLine")
    local endPad = waitFor(path, "Goal").Pad
    if startLine:FindFirstChild("Part") then
        goToPart(startLine:FindFirstChild("Part").CFrame + Vector3.new(0,3,0))
    else
        goToPart(startLine.CFrame + Vector3.new(0,3,0))
    end
    task.wait(math.random(2,3))
    goToPart(endPad.CFrame + Vector3.new(0,3,0))
end

local project = loadstring(game:HttpGet("https://raw.githubusercontent.com/idonthaveoneatm/Libraries/normal/quake/src"))()
local main = project:Window({
    Title = "Pet Simulator 99"
})
local farming = main:Tab({
    Name = "Farming",
    tabColor = Color3.fromHex("#71d1f5"),
    Image = "rbxassetid://10709769841"
})
local teleports = main:Tab({
    Name = "Teleports",
    tabColor = Color3.fromHex("#9bf038"),
    Image = "rbxassetid://15555209580"
})
local minigames = main:Tab({
    Name = "Minigames",
    tabColor = Color3.fromHex("#d19b4a"),
    Image = "rbxassetid://10723376114"
})
local rewards = main:Tab({
    Name = "Rewards",
    tabColor = Color3.fromHex("#da0a48"),
    Image = "rbxassetid://10723396402"
})
local misc = main:Tab({
    Name = "Miscellaneous",
    tabColor = Color3.fromHex("#34d793"),
    Image = "rbxassetid://10709819149"
})
local event = main:Tab({
    Name = "Event",
    tabColor = Color3.fromHex("#00ff00"),
    Image = "rbxassetid://10734964600"
})
local credits = main:Tab({
    Name = "Credits",
    Image = "rbxassetid://10747373176"
})

local antiAFK
farming:Toggle({
    Name = "Farm Coins",
    Default = false,
    Callback = function(value)
        config.farm.toggle = value

        while config.farm.toggle and task.wait() do
            for _, v in ipairs(Breakables:GetChildren()) do
                if v:FindFirstChild("Hitbox", true) then
                    local part = v:FindFirstChild("Hitbox", true)
                    if calcDistance(part, HumanoidRootPart) <= config.farm.radius then
                        if config.farm.singleTarget then
                            local tmpName = v.Name
                            repeat
                                task.wait(config.farm.wait)
                                Network.Breakables_PlayerDealDamage:FireServer(v.Name)
                            until not Breakables:FindFirstChild(v.Name) or calcDistance(part, HumanoidRootPart) > config.farm.radius or not config.farm.toggle or not config.farm.singleTarget
                        else
                            if not table.find(currentCoins, v.Name) then
                                table.insert(currentCoins, v.Name)
                                task.spawn(function()
                                    local tmpPart = part
                                    local tmpName = v.Name
                                    repeat
                                        task.wait(config.farm.wait * math.random(1, 2))
                                        Network.Breakables_PlayerDealDamage:FireServer(tmpName)
                                    until not Breakables:FindFirstChild(tmpName) or calcDistance(tmpPart, HumanoidRootPart) > config.farm.radius or config.farm.singleTarget or not config.farm.toggle
                                    table.remove(currentCoins, table.find(currentCoins, v.Name))
                                end)
                            end
                        end
                    end
                end
            end
        end
        table.clear(currentCoins)
    end
})
farming:Toggle({
    Name = "Single Target",
    Default = false,
    Callback = function(value)
        config.farm.singleTarget = value
    end
})
farming:TextBox({
    Name = "Radius (Recommended: 70)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.radius = tonumber(value)
        else
            config.farm.radius = 40
            sendNotification("Radius Error", "You need the RADIUS to be a number. It is now 40", 50)
        end
    end
})
farming:TextBox({
    Name = "Wait Time (Recommended: 0.2)",
    Callback = function(value)
        if tonumber(value) then
            config.farm.wait = tonumber(value)
        else
            config.farm.wait = 0.2
            sendNotification("Wait Time Error", "You need the WAIT TIME to be a number. It is now 0.2", 50)
        end
    end
})
farming:Section("Collection")
farming:Label("Auto Collect Orbs is currently broken/patched")
local collectLootbags
collectLootbags = farming:Toggle({
    Name = "Collect Lootbags",
    Default = false,
    Callback = function(value)
        config.autoLootbag = value
        while config.autoLootbag and task.wait() do
            for _, lootbag in ipairs(Lootbags:GetDescendants()) do
                if not config.autoLootbag then break end
                if lootbag:IsA("MeshPart") then
                    lootbag.CFrame = HumanoidRootPart.CFrame
                end
            end
        end
    end
})
farming:Section("Egg Farming")
farming:Label("You must be near eggs to hatch them")
farming:Dropdown({
    Name = "Egg to farm",
    Items = eggTable,
    Multiselect = false,
    Callback = function(eggPicked)
        config.egg.selectedEgg = eggPicked
    end
})
farming:Slider({
    Name = "Amount of eggs",
    Step = 1,
    Max = 99,
    Min = 1,
    InitialValue = 1,
    Callback = function(eggAmount)
        config.egg.amount = eggAmount
    end
})
farming:Toggle({
    Name = "Farm selected egg",
    Default = false,
    Callback = function(value)
        config.egg.farm = value
        while config.egg.farm and task.wait() do
            local splitName = string.split(config.egg.selectedEgg, " | ")
            Network.Eggs_RequestPurchase:InvokeServer(splitName[2],tonumber(config.egg.amount))
            task.wait(0.4)
            repeat 
                task.wait()
                clickPosition(math.huge,math.huge)
            until not game.workspace.Camera:FindFirstChild("Eggs") or not config.egg.farm
            task.wait(0.75)
        end 
    end
})
farming:Section("Fishing")
local fishingStatus = false
farming:Toggle({
    Name = "Start fishing",
    Default = false,
    Callback = function(value)
        config.fishing = value
        antiAFK:SetValue(config.fishing)
        checkActive("Fishing", config.fishing)
        task.wait(0.2)
        local fishing = waitFor(instanceContainer.Active, "Fishing")
        local fishingModule = require(fishing.ClientModule.FishingGame)
        local Layer1 =  waitFor(fishing.Water, "Layer1")
        local Bobbers = waitFor(fishing, "Bobbers")
        local L1Position = Layer1.Position
        local function fishingRemote(arg1, arg2)
            if arg2 then
                return Network.Instancing_FireCustomFromClient:FireServer("Fishing",arg1, arg2)
            end
            return Network.Instancing_FireCustomFromClient:FireServer("Fishing",arg1)
        end
        local function isBubbling()
            local bubbling = false
            for _,host in ipairs(Debris:GetChildren()) do
                if host.Name == "host" and host:FindFirstChild("Attachment") and (host.Attachment:FindFirstChild("Bubbles") or host.Attachment:FindFirstChild("Rare Bubbles")) then
                    local distance = (HumanoidRootPart.Position.X - host.Position.X)
                    if distance <= 2 then
                        bubbling = true
                    end
                end
            end
            return bubbling
        end
        local oldStartGame,oldStopGame,oldIsFishInBar
        oldStartGame = hookfunction(fishingModule.StartGame, function(...)
            fishingStatus = true
            return oldStartGame(...)
        end)
        oldStopGame = hookfunction(fishingModule.StopGame, function(...)
            fishingStatus = false
            return oldStopGame(...)
        end)
        oldIsFishInBar = hookfunction(fishingModule.IsFishInBar, function(...) 
            if config.fishing then
                return true
            else
                return oldIsFishInBar(...)
            end
        end)
        while config.fishing and task.wait() do
            if HumanoidRootPart.Position ~= L1Position and config.fishing then
                goToPart(Layer1.CFrame)
            end
            fishingRemote("RequestCast", Vector3.new(L1Position.X,L1Position.Y,L1Position.Z))
            repeat task.wait() until isBubbling() or not config.fishing
            fishingRemote("RequestReel")
            repeat task.wait() until (not fishingStatus) or not config.fishing
        end
        goToPart(fishing.Interactable:FindFirstChild("Pad", true).CFrame + Vector3.new(0,3,0))
    end
})

teleports:Label("Miscellaneous")
teleports:Button({
    Name = "Remove water",
    Callback = function() 
        for _, water in ipairs(Map:GetDescendants()) do
            if water:IsA("Folder") and water.Name == "Water Bounds" then
                water:Destroy()
            end
        end
    end
})
teleports:Section("Zones")
local selectedZone = ""
local goToZone
teleports:Dropdown({
    Name = "Zones",
    Items = zoneNames,
    Multiselect = false,
    Callback = function(name) 
        selectedZone = name
        goToZone:SetText("Go to "..selectedZone)
    end
})
goToZone = teleports:Button({
    Name = "Go to none",
    Callback = function()
        goToPart(zoneTable[selectedZone])
    end
})
teleports:Section("Vending Machines")
local vendingName = ""
local goToVendingMachine
teleports:Dropdown({
    Name = "Vending Machines",
    Items = vendingMachines.Names,
    Multiselect = false,
    Callback = function(name)
        vendingName = name
        goToVendingMachine:SetText("Go to "..vendingName)
    end
})
goToVendingMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = vendingMachines.Zones[vendingName]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local vendingPad = waitFor(world.INTERACT.Machines, vendingName).Pad.CFrame
        goToPart(vendingPad)
    end
})
teleports:Section("Other Machines")
local otherMachine = ""
local goToOtherMachine
teleports:Dropdown({
    Name = "Other Machines",
    Items = otherMachines.Names,
    Multiselect = false,
    Callback = function(name)
        otherMachine = name
        goToOtherMachine:SetText("Go to "..otherMachine)
    end
})
goToOtherMachine = teleports:Button({
    Name = "Go to none",
    Callback = function()
        local zone = otherMachines.Zones[otherMachine]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local machinePad = waitFor(world.INTERACT.Machines, otherMachine).Pad.CFrame
        goToPart(machinePad)
    end
})

local selectedMinigame = ""
local goToMinigame
minigames:Dropdown({
    Name = "Select minigame",
    Items = minigamesTable,
    Multiselect = false,
    Callback = function(item)
        selectedMinigame = item
        goToMinigame:SetText(selectedMinigame)
    end
})
goToMinigame = minigames:Button({
    Name = "Go to none",
    Callback = function()
        goToPart(Things.Instances[selectedMinigame]:FindFirstChild("Enter", true).CFrame)
    end
})
minigames:Section("Auto Complete")
minigames:Button({
    Name = 'Complete "Spawn Obby"',
    Callback = function()
        checkActive("SpawnObby")
        task.wait(1)
        local spawnObby = waitFor(instanceContainer.Active, "SpawnObby")
        completeObby(spawnObby)
    end
})
minigames:Button({
    Name = 'Complete "Minefield"',
    Callback = function()
        checkActive("Minefield")
        task.wait(1)
        local minefield = waitFor(instanceContainer.Active, "Minefield")
        local mines = waitFor(minefield, "Mines")
        local finish = waitFor(minefield, "Finish")
        local nextX,nextZ = 0, 0
        for _,mine in ipairs(mines:GetChildren()) do
            if nextX == 0 then
                local oldPos = mine.Pad.CFrame
                mine.Pad.CanCollide = false
                nextX = mine.Pad.Position.X
                nextZ = mine.Pad.Position.Z
                mine.Pad.CFrame = HumanoidRootPart.CFrame
                task.wait(0.2)
                mine.Pad.CFrame = oldPos
                mine.Pad.CanCollide = true
                if tostring(mine.Pad.BrickColor) == "Really red" then
                    nextZ = nextZ + 10
                    task.wait(3)
                else
                    nextX = nextX + 10
                end
            else
                if mine.Pad.Position.X == nextX and mine.Pad.Position.Z == nextZ then
                    local oldPos = mine.Pad.CFrame
                    mine.Pad.CanCollide = false
                    mine.Pad.CFrame = HumanoidRootPart.CFrame
                    task.wait(0.2)
                    mine.Pad.CFrame = oldPos
                    mine.Pad.CanCollide = true
                    if tostring(mine.Pad.BrickColor) == "Really red" then
                        nextZ = nextZ + 10
                        task.wait(3)
                    else
                        nextX = nextX + 10
                    end
                end
            end
        end
        goToPart(finish.CFrame)
    end
})
minigames:Button({
    Name = 'Complete "Jungle Obby"',
    Callback = function() 
        checkActive("JungleObby")
        task.wait(1)
        local jungleObby = waitFor(instanceContainer.Active, "JungleObby").Interactable
        task.wait(1)
        completeObby(jungleObby)
    end
})
minigames:Button({
    Name = 'Complete "Atlantis"',
    Callback = function() 
        checkActive("Atlantis")
        task.wait(1)
        local atlantis = waitFor(instanceContainer.Active, "Atlantis")
        local rings = waitFor(atlantis, "Rings")
        for i=1,31 do
            local ring = waitFor(rings, tostring(i))
            task.wait(0.4)
            HumanoidRootPart.CFrame = ring.Collision.CFrame
        end
    end
})
minigames:Button({
    Name = 'Complete "Pyramid Obby"',
    Callback = function() 
        checkActive("PyramidObby")
        task.wait(1)
        local pyramidObby = waitFor(instanceContainer.Active, "PyramidObby").Interactable
        completeObby(pyramidObby)
    end
})
minigames:Button({
    Name = 'Complete "Ice Obby"',
    Callback = function() 
        checkActive("IceObby")
        task.wait(1)
        local iceObby = waitFor(instanceContainer.Active, "IceObby").Interactable
        task.wait(1)
        completeObby(iceObby)
    end
})
minigames:Button({
    Name = 'Complete "Minecart"',
    Callback = function()
        checkActive("Minecart")
        task.wait(1)
        local minecart = waitFor(instanceContainer.Active, "Minecart")
        HumanoidRootPart.CFrame = CFrame.new(0,0,0) + Vector3.new(-1380.3746337890625, -102.0365982055664, -4659.6044921875)
        task.wait(1)
        local goalPad = waitFor(minecart.Interactable, "Goal").Pad
        task.wait(math.random(2,3))
        goToPart(goalPad.CFrame + Vector3.new(0,3,0))
    end
})

rewards:Toggle({
    Name = 'Collect Time Rewards',
    Default = false,
    Callback = function(value)
        config.timeRewards = value
        collectLootbags:SetValue(config.timeRewards)
        while config.timeRewards and task.wait() do
            for i=1,12 do
                Network:FindFirstChild("Redeem Free Gift"):InvokeServer(i)
            end
        end
    end
})
rewards:Section("Daily Rewards")
local rewardType = ""
local getDailyReward
rewards:Dropdown({
    Name = "Reward Type",
    Items = dailyRewards.Names,
    Callback = function(value)
        rewardType = value
        getDailyReward:SetText("Get: "..rewardType)
    end
})
getDailyReward = rewards:Button({
    Name = "Get: ",
    Callback = function()
        local oldPos = HumanoidRootPart.CFrame
        local zone = dailyRewards.Zones[rewardType]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT.Machines, rewardType).Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
        task.wait(0.2)
        goToPart(oldPos)
    end
})
rewards:Section("Other Rewards")
local otherRewardType = ""
local goToOtherReward
rewards:Dropdown({
    Name = "Reward Type",
    Items = otherRewards.Names,
    Callback = function(value)
        otherRewardType = value
        goToOtherReward:SetText("Go to "..otherRewardType)
    end
})
goToOtherReward = rewards:Button({
    Name = "Go to none ",
    Callback = function()
        local zone = otherRewards.Zones[otherRewardType]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT.Machines, otherRewardType).Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
    end
})
rewards:Button({
    Name = "Go to Crystal Chest",
    Callback = function() 
        local zone = "3 | Castle"
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local rewardPad = waitFor(world.INTERACT, "CrystalChest").Pad.CFrame
        goToPart(rewardPad + Vector3.new(0,3,0))
    end
})

misc:Label("These are things that dont fit in a category")
antiAFK = misc:Toggle({
    Name = "Anti AFK",
    Default = false,
    Callback = function(value)
        config.antiafk = value
        while config.antiafk and task.wait() do
            LocalPlayer.Character.Humanoid:ChangeState(3)
            task.wait(math.random(120,180))
        end
    end
})
local shrineButton
shrineButton = misc:Button({
    Name = "Collect Shrines (Maybe)",
    Callback = function()
        for i=1,65 do
            shrineButton:SetText("Progress: "..tostring(i).."/65")
            Network.Relic_Found:InvokeServer(i)
        end
        shrineButton:SetText("Collect Shrines (Maybe)")
    end
})

event:Label("Presents are found in both normal zones and minigames!")
local presentsButton
presentsButton = event:Button({
    Name = "Collect Presents",
    Callback = function()
        for i=1,75 do
            presentsButton:SetText("Progress: "..tostring(i).."/75")
            Network.Present_Found:InvokeServer(i)
        end
        presentsButton:SetText("Collect Presents")
    end
})
event:Toggle({
    Name = "Farm Candy Canes",
    Default = false,
    Callback = function(value)
        config.event.farm = value
        local candycanes = {}
        if config.event.farm then
            goToPart(zoneTable["1 | Spawn"] + Vector3.new(0,3,0))
            task.wait(3)
        end
        while config.event.farm and task.wait() do
            local count = 0
            for _,zone in ipairs(zoneNames) do
                if not config.event.farm then break end
                if count > 0 then
                    goToPart(zoneTable[zone] + Vector3.new(0,3,0))
                    task.wait(3)
                else
                    goToPart(zoneTable[zone] + Vector3.new(0,3,0))
                    task.wait(1)
                end
                count = 0
                for _,cc in ipairs(Breakables:GetDescendants()) do
                    if not config.event.farm then break end
                    if cc:IsA("MeshPart") and cc.MeshId == "rbxassetid://8269538460" then
                        count = count + 1
                        table.insert(candycanes, cc.Parent)
                    end
                end
                for _,v in ipairs(candycanes) do
                    local hitbox = v:findFirstChild("Hitbox", true)
                    local s,e = pcall(function() 
                        goToPart(hitbox.CFrame + Vector3.new(0,5,0))
                    end)
                    if e then
                        table.remove(candycanes, table.find(candycanes, v.Name))
                        return
                    end
                    task.wait(0.2)
                    repeat
                        task.wait(0.2)
                        Network.Breakables_PlayerDealDamage:FireServer(v.Name)
                    until not Breakables:FindFirstChild(v.Name) or not config.event.farm
                    table.remove(candycanes, table.find(candycanes, v.Name))
                end
                table.clear(candycanes)
            end
        end
    end
})
event:Section("Other Machines")
local eventThing = ""
local goToEventThing
event:Dropdown({
    Name = "Other Machines",
    Items = eventThings.Names,
    Multiselect = false,
    Callback = function(name)
        eventThing = name
        goToEventThing:SetText("Go to "..eventThing)
    end
})
goToEventThing = event:Button({
    Name = "Go to none",
    Callback = function()
        local zone = eventThings.Zones[eventThing]
        goToPart(zoneTable[zone] + Vector3.new(0,50,0))
        local world = waitFor(Map, zone)
        local eventPad = waitFor(world.INTERACT.Machines, eventThing).Pad.CFrame
        goToPart(eventPad)
    end
})
event:Paragraph({
    Title = "TLDR",
    Body = "This won't work after collecting presents with the toggle you will need to rejoin the game inorder to see it change"
})
local eventStats
eventStats = event:Button({
    Name = "Check Stats",
    Callback = function()
    local opened = 0
    local unopened = 0
    for _,present in ipairs(Things.Presents:GetChildren()) do
        if present.Name == "Present" and present:FindFirstChild("ClickDetector") then
           unopened = unopened + 1
        elseif present.Name == "Present" and not present:FindFirstChild("ClickDetector") then
            opened = opened + 1
        end
    end
    eventStats:SetText("Opened: "..tostring(opened).." Unopened: "..tostring(unopened).." Total: 75")
    end
})

credits:Label("UI: griffindoescooking")
credits:Label("Script: griffindoescooking, project L")
credits:Button({
    Name = "project L",
    Callback = function()
        setclipboard("https://discord.gg/Mw7rYHDNw4")
    end
})
credits:Section("Support: ")
credits:Button({
    Name = "Discord",
    Callback = function()
        setclipboard("https://discord.gg/DBPHwFyCVT")
    end
})
